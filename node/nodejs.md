# 一、Node简介
## 1. 性能方面，单线程弊端：
	1). 无法利用多核CPU
	2). 错误会引起整个应用退出，应用的健壮性值得考验
	3). 大量计算占用CPU，导致无法继续调用异步I/O
	***Node采用child_process子进程，来解决单线程中大量计算问题
## 2. 应用场景
	1). I/O密集型：
		？Node可以有效组织起更多硬件资源，是否可利用多核CPU呢，什么区别
	2). CPU密集型：经测试性能在C之后java\go\ruby\php\python之前
		CPU密集型应用给Node带来的挑战：由于javascript单线程，如有长时间运行计算，
		会导致CPU时间片不能释放，使得后续I/O无法发起，因此要合理调度。
# 二、模块规范机制
		JavaScrip先天缺乏模块，一直使用<script>标签引入代码，命名空间约束代码，达到安全和易用。
	经过十几年发展，社区为其制订了相应规范：
	## 1. CommonJS规范：弥补当前javascript没有标准的缺陷，使其具备开发大型应用的基础能力，而不是小脚本程序阶段。
		(Node借鉴了CommonJS的Modules规范，实现易用模块系统NPM。)
		1). 模块引用：var math = require('math);
		2). 模块定义:一个文件就是一个module，exports是其属性，实现导出
		3). 模块标识：即require()方法的参数，相对或绝对路径
	## 2. Node的模块实现
		1). 模块路径：是定位文件模块时的查找策略，为一个路径组成的数组，怎么生成呢？
			a). 创建module_path.js，内容为console.log(module.paths)
			b). 执行node module_path.js
# 三、异步I/O
## 1. 异步I/O实现现状
>a. 阻塞I/O与非阻塞I/O区别：阻塞I/O完成获取数据过程，非阻塞I/O不带数据直接返回。解决方法：通过轮询，确保获取完整的数据需求，即需重复调用I/O操作来确认是否完成。现存轮询技术：
>>read：重复调用检查I/O状态，性能最低。

>>select：read基础上的改进，通过文件描述符 的时间状态来判断，最多可同时检查1024文件描述符。

>>poll：select改进，链表方式避免数组长度限制。

>>epoll：Linux下效率最高的I/O事件通知机制，进入轮询若未检查到I/O事件，将会休眠，直到事件发生将它唤醒。真实利用了事件通知、执行回调的方式，而不是遍历查询，不会浪费CPU，执行效率较高。但CPU休眠等待也是浪费。

>>kqueue：与epoll类似，不过仅存在FreeBSD系统下

>b. 理想的非阻塞异步I/O

>>应用程序发起非阻塞调用，无需通过遍历或事件唤醒等方式轮询，可直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序即可

>c. 现实的异步I/O

>>数据获取：部分线程进行阻塞I/O或者非阻塞I/O + 轮询

>>>计算处理：1个线程处理

>>>通过线程通信，将获取的数据进行传递，实现异步I/O。

>>Node是单线程，仅指JavaScript执行在单线程中罢了，内部完成I/O任务的另有线程池-
## 2. 异步I/O的实现环节：
>事件循环：Node自身执行模型，进程启动时，Node创建一个类似于while(true)的循环，执行一次循环成为Tick。

>观察者：

>请求对象
## 3. 服务器模型
>同步式。一次处理一个请求，其余请求处于等待状态
>
>每进程/每请求。为每个请求启动一个进程，这样可处理多个请求。
>
>每线程/每请求。为每个请求启动一个线程。
# 四、异步编程
## 1.函数式编程
>>高阶函数：可将函数作为参数或返回值的函数
>>
>>偏函数：指定部分参数产生一个新的定制函数的形式
